오픈소프트웨어(N) 1_14조 조별과제 report
======
목차
------
1. 추진배경-임하늘, 강다현
2. 기술 분석-임하늘, 강다현
3. 유사서비스 분석- 임하늘, 강다현
4. 사용 오픈소스(설명, 선정이유, 상세분석, 활용계획)- 전원
5. 서비스 구현을 위한 설계-정재훈
6. GUI 소개- 곽범석, 전세정
7. API 정의-곽범석, 국승빈, 권화경, 정세영
8. DFD-곽범석, 국승빈, 권화경, 정세영
9. 마무리 및 소감

추진배경
------

기술분석
------

유사서비스 분석
------

사용 오픈소스
------
# NGINX


## (1)NGINX
 Nginx(엔진엑스)는 igor Sysoev라는 러시아 개발자가 동시접속 처리에 특화된 웹 서버 프로그램이다.
 Apache보다 동작이 단순하고, 전달자 역할만 하기 때문에 동시접속 처리에 특화되어 있다. 
 즉 경량 웹 서버이다.
 HTTP Web Sever로 활용되기도 하고, Reverse Proxy Sever 로 활용하여 WAS서버의 부하를 줄일 수 있는 로드 밸러서로 활용되기도 한다.  

## (2) Nginx(웹서버)의 역할
- 정적 파일을 처리하는 HTTP 서버로서의 역할 (HTTP 프로토콜을 준수)
웹서버의 역할은 HTML, CSS, Javascript, 이미지와 같은 정보를 웹 브라우저(Chrome, lexplore, Opera, Firefox)에 전송하는 역할을 한다.   
- 응용프로그램 서버에 요청을 보내는 리버스 프록시로서의 역할
두 번째 역할은 리버스 프록시(reverse proxy)인데, 즉 클라이언트는 가짜 서버에 요청(request)하면, 프록시 서버가 배후 서버(reverse server)로부터 데이터를 가져오는 역할을 한다. 여기서 프록시 서버가 Nginx, 배후서버가 응용프로그램 서버를 의미한다.
웹 응용프로그램 서버에 리버스 프록시(Nginx)를 두는 이유는 요청(request)에 대한 버퍼링이 있기 때문이다. 클라이언트가 직접 App 서버에 직접 요청하는 경우, 프로세스 1개가 응답 대기 상태가 되어야만 한다. 따라서 프록시 서버를 둠으로써 요청을 배분하는 역할을 한다.

## (3)Nginx의 구조 
 Nginx는 하나의 Master process와 다수의 Worker Process로 구성되어 실행이 된다. Master Process는 설정 파일을 읽고, 유효성을 검사하고 Worker Process를 관리한다. 
 모든 요청은 Worker Process에서 처리한다.
 Nginx는 이벤트 기반 모델을 사용하고, Worker Process의 개수는 설정 파일에서 정의되며, 정의된 프로세스 개수와 사용 가능한 CPU 코어 숫자에 맞게 자동으로 조정이 된다. 

## (4) Nginx 라이선스
NGINX의 라이선스는 BSD 2-Clause 라이선스를 사용하는데, "Simplified BSD 라이선스" 또는 "FreeBSD 라이선스"라고 부르기도 한다. 
즉, 원저작자를 밝히고 원래 라이선스를 그대로 유지하는 조건만 갖추면, 자유롭게 수정 및 재배포가 가능하다. 다시말해, 수정된 소스를 공개하거나 소스코드를 제공해야 할 의무도 없는 자유로운 라이선스이다.


# Lightfm



## (1) LightFM

많은 신규 고객과 잦은 상품 등록(cold-start)에 대응할 수 있도록 Content-based와 Collaborative Filtering의 장점을 결합한 Hybrid형 모델이다. 

LightFM은 학습 데이터에서 Collaborative 데이터와 User/Item Feature를 모두 사용하고, LightFM에서 생성된 Embedding 벡터는 feature에 대한 중요한 의미 정보를 포함하고 있고, 이는 tag 추천과 같은 일에서 중요하게 사용될 수 있다는 특징을 가지고 있다. 

LightFM은 BPR(Bayesian Personilsed Ranking), WARP(Weighted Approcimate-Rank Pairwise)와 같은 랭킹 손실 함수를 기반으로 데이터를 학습하며, 고객이 상품에 행동(구매, 평점 등)을 취할 확률을 예측하여 높은 확률의 상품을 고객에게 추천하는 방식이다.  

LightFM은 cold-start에 대응 가능하다는 장점과 모델의 평가 지표로 AUC 평가 함수가 패키지로 제공되는 장점 때문에 LightFM을 선정하게 되었다.

본 모델에서 LightFM은 학습된 고객 데이터, 상품 데이터, 고객이 이전에 구매한 상품에 대한 평가 데이터를 WARP 랭킹 손실 함수로 학습하고,  고객 ID를 기준으로 Predict 함수를 사용하여 추천 데이터를 NumPy 배열 형태로 반환한다.



## (2) LightFM의 라이선스

Apache 2.0 라이선스를 사용한다. 아파치 재단이나 재단의 프로젝트에 의해서 만들어진 모든 소프트웨어는 현재 Apache License 2.0에 의해 배포되고 있다.

### 배포시 의무사항

- 수취인에게 라이선스 사본 제공
- 수정된 파일에 대해 수정사항을 표시한 안내문구 첨부
- 저작권, 특허, 상표, attribution에 대한 고지사항을 소스코드 또는 "NOTICE" 파일 등에 포함
- 최초개발자 등을 위해 보증을 면제하고, 책임을 제한

### 허용

- 자유로운 소스코드의 복제, 배포, 수정

- 명시적 특허 라이선스의 허용

- 조합저작물(Lager Work) 작성 및 타 라이선스로의 배포 허용

- 상업적 이용 허용

- 소스코드 공개의무 X



# Pandas 



## (1) Pandas

Pandas는 수치형 테이블과 시계열 데이터를 조작하고 운영하기 위한 데이터를 제공하는데, 3조항 BSD 라이선스 조건 하에서 무료로 사용 가능하다.

Pandas의 이름은 계량 경제학에서 사용되는 용어인 'PANel DAta'의 앞 글자를 따서 지어졌다. 당연히 실제 동물인 판다와는 아무런 관련이 없지만, 이름이 이름이니만큼 각종 개발 관련 사이트에서 판다 이미지를 활용하여 Pandas를 소개하곤 한다.

데이터 조작 및 분석을 위한 Python 프로그래밍 언어 용으로 작성된 소프트웨어 라이브러리이다.

Pandas는 주로 데이터 분석에 사용된다. Pandas를 사용하면 쉼표로 구분된 값 , JSON , SQL 및 Microsoft Excel 과 같은 다양한 파일 형식에서 데이터를 가져올 수 있다.

데이터의 병합 등의 각종 데이터 처리 동작을 허용, 재편,  선택 뿐만 아니라 청소 데이터 및 데이터 승강이 가능하다.

New BSD 라이센스를 사용한다.

본 모델에서는 LightFM이 반환한 NumPy 배열을 DataFrame으로 변환하여 최종적으로 추천된 상품을 반환하는 데에 사용된다. Pandas는 Numpy의 대부분의 기능을 수행할 수 있고, Numpy보다 용이한 접근성을 가지고 있기 때문에 선정하게 되었다.



## (2) Pandas의 세부 기능

- Python 자료구조와의 호환(List, Tuple, Dict, NumPyArray 등)
- 큰 데이터의 빠른 Indexing, Slicing, Sorting
- 두 데이터 간의 Join(행, 열 방향) 기능
- 데이터의 티봇팅 및 그룹핑
- 데이터의 통계 및 시각화 기능
- 외부 데이터를 입력받아 Pandas 자료구조로 저장 및 출력(CSV, 구분자가 있는 txt, 엑셀데이터, SQL Database, XML 등)



# scikit-learn



## (1) scikit-learn
cikit-learn이란 python을 대표하는 머신러닝 라이브러리이다. '사이킷런'이라고 부르기도 한다.

scikit-learn은 오픈 소스로 공개되어 있으며, 개인, 비즈니스 관계없이 누구나 무료로 사용가능하다. scikit-learn은 현재도 활용하여 개발이 이루어지고 있으며, 인터넷 상에서 정보를 찾기에도 쉽다.

많은 머신러닝 알고리즘이 구현되어 있는데, 어떤 알고리즘도 같은 방식으로 이용이 가능하다. 또, 샘플 데이터 셋(토이 데이터 셋)이 부속되어 있으므로, 설치하여 바로 기계 학습을 시험해볼 수 있다.

그러므로 초심자가 기계학습을 배우기 시작할 때 적합한 라이브러리라고 말한다. 다양한 분류, 회귀, 그리고 서포트 벡터 머신, 랜덤 포레스트, 그라디언트 부스팅, k-평균 , DBSCAN을 포함한 클러스터링 알고리즘을 특징으로 한다. 

본 모델에서 학습에 사용되는 데이터를 전달받아 벡터 값으로 변환하여 LightFM이 정상적으로 데이터를 학습할 수 있도록 한다. scikit-learn은 라이브러리 외적으로는 scikit 스택을 사용하고 있기 때문에 다른 라이브러리와의 호환성이 좋고, 내적으로는 통일된 인터페이스를 가지고 있기 때문에 매우 간단하게 여러 기법을 적용할 수 있어 쉽고 빠르게 최상의 결과를 얻을 수 있다는 장점이 있기 때문에 선정하게 되었다.



## (2) scikit-learn의 세부 기능

#### **1)** **분류（classification）**

주어진 데이터가 어느 클래스에 속하는 판별하는 것이다.

**(1)** **SGD（stochastic gradient descent）**

대규모 데이터(10만건 이상)의 경우 추천한다. 선형의 클래스 분류 방법이다.

**(2)** **커넬근사**

SGD로 잘 분류할 수 없는 경우에 이용하며, 비선형적인 클래스 분류방법이다. 이것도 대규모 데이터에 적합하다.

**(3) Linear SVC**

중소규모(10만건 미만)의 경우 추천하며, 선형의 클래스 분류 방법이다.

**(4) k근접법**

Linear SVC로 잘 분류되지 않는 경우 사용하며, 비선형적인 클래스 분류 방법이다. 이것은 중소 규모의 데이터 분류에 추천한다.



#### **2) 회귀（regression）**

전달된 데이터를 바탕으로 값을 예상한다.

**(1) SGD（stochastic gradient descent）**

대규모 데이터(10만건 이상)의 경우 추천하는 선형 회귀 분석 방법이다.

**(2)** **LASSO、ElasticNet**

중소규모(10만건 미만)으로 설명 변수의 일부가 중요한 경우에 추천하는 회귀 분석 방법이다.

**(3) Ridge、Liner SVR**

중소규모(10만건 미만)으로 설명 변수의 전부가 중요한 경우에 추천하는 회귀 분석 방법이다.

**(4) SVR（가우스 커넬）、Ensemble**

Ridge또는 Liner SVR로 잘 분석되지 않는 경우 이용하며, 비선형적 회귀 분석 방법이다.



#### **3)클러스터링（clustering）**

전달된 데이터를 어떤 규칙에 따라 나누는 것이다.

**(1) KMeans**

몇 개의 클러스터를 분할할지, 사전에 정해둔 경우 추천하는 클러스터링분석방법이다.

대규모 데이터의 경우, MiniBatch라고 해서 데이터를 나누면서 학습시키는 방법을 취한다.

**(2) 스펙트럼 클러스터링(GMM)**

KMeans로 잘 분석되지 않는 경우에 이용하며, 비선형적인 클러스터링 분석 방법이다.

**(3) MeanShift、VBGMM**

몇 개의 클러스터로 나눌지에 대해, 사전에 정할 수 없는 경우에 추천하는 클러스터링 분석 방법이다.



#### **4) 그 외 기타 기능**

**(1) 차원감소**

전달된 데이터의 차원 수가 많은 경우, 학습효율이 떨어지므로 차원을 감소시키는 전처리를 실시한다.

PCA、커넬PCA、Isomap、SpectralEmbedding등의 방법이 있다.

**(2) 하이퍼 파라미터의 최적화**

기계학습을 실행할 때, 학습 방법 등을 조정하는 수치를 하이퍼 파라미터라고 한다.

그리드 서치, 크로스밸리테이션 등의 방법이 있다.



## (3)scikit-learn의 라이선스

Pandas와 마찬가지로 New BSD라이선스를 사용한다. 3-Clause BSD License(BSD-3-Clause) 와 같은 의미이다. 2-Clause BSD License를 기반으로 한다. 

### 배포시 의무사항

- 재배포시 저작권 표시, 준수 조건 및 보증부인에 대한 고지사항을 소스코드 또는 문서 및 기타 자료에 포함

- 최초개발자나 기여자의 이름을 제품에 대한 보증이나 홍보에 사용하지 못함
- BSD 라이선스가 걸린 소프트웨어로 인하여 법률상/도의상 피해가 발생하더라도, 그 책임을 저작권자에게 물을 수 없다.

### 허용

- 누구나 복제, 수정, 배포 가능
- 소스코드 공개의무 X
- 조합저작물(Lager Work) 작성 및 타 라이선스 배포 가능(조건부)
- 상업적 이용 가능

서비스 구현을 위한 설계
------

GUI 소개
------

API 정의
------

DFD
------

마무리 및 소감
------
